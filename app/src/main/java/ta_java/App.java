// /*
//  * This Java source file was generated by the Gradle 'init' task.
//  */
package ta_java;

import ta_java.model.Option;
import ta_java.model.Stock;
import ta_java.service.OptionService;
import ta_java.service.StockService;
import ta_java.exception.ApplicationException;
import ta_java.exception.DatabaseException;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.slf4j.LoggerFactory;
import org.slf4j.Logger;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController; 

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.*;
import static java.lang.Math.sqrt;
import static org.mockito.ArgumentMatchers.booleanThat;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import static java.lang.Math.exp;
import java.util.stream.Collectors;

import org.apache.commons.math3.distribution.NormalDistribution;


@EnableScheduling
@Slf4j
@Configuration
@EnableAutoConfiguration
@ComponentScan
@SpringBootApplication

/**
 * This is the main App class that runs the whole app.
 */
public class App implements CommandLineRunner {
  public static void main(String[] args) {
    SpringApplication.run(App.class);
  }

  @Autowired
  StockService stockService;

  @Autowired
  OptionService optionService;


  // creating a logger 
  Logger logger = LoggerFactory.getLogger(App.class); 

  int updateNum = 1;
  // logger

    /**
 * This method returns the sum of two integers.
 *
 * @param file CSV File with tickers and their price and quantity
 * @return the records read from the CSV file delimited by lines
 * @throws java.io.IOException
 */
  public List<List<String>> readCsvFile(File file) throws IOException {
    List<List<String>> records = new ArrayList<>();
    boolean first = true;
    try (BufferedReader br = new BufferedReader(new FileReader( file))) {
      
        String line;
        while ((line = br.readLine()) != null) {
          if (first) {
            first = false;
            continue;}
            String[] values = line.split(",");
            records.add(Arrays.asList(values));
        }
    }
    return records;
}

    /**
 * This method creates stock and associated call and put options. It prints stock, their associated options and calculated real time value as denoted by European Option Pricing Formula.
 *
 * @param stockService uses StockService to create Stock records in database
 * @param optionService uses OptionService to create Option records in database and links them to associated stocks
 */
  public void createCallPutOptions(StockService stockService, OptionService optionService) throws DatabaseException{
    // readfile and create objects:
    Stock s = stockService.findByName("AAPL");
    System.out.println(s);
    Option callOption1 = optionService.create(new Option(50, 5, 30, s, true));
    Option putOption1 = optionService.create(new Option(60, 5, 30, s, false));

    System.out.println("For stock:" + s);
    System.out.println("For call option:" + callOption1);
    System.out.println("Real time value of call option: " + Double.toString(callOption1.getRealTimeValue()));
    System.out.println("For put option:" + putOption1);
    System.out.println("Real time value of put option: " + Double.toString(putOption1.getRealTimeValue()));

    // simulating 2000 options created:
    for (int i=  90; i < 2090; i++){
      callOption1 = optionService.create(new Option(i, 5, 30, s, true));
      putOption1 = optionService.create(new Option(i + 10, 5, 30, s, false));
    }

  }

    /**
 * This method reads file and add all associated stocks and call options to database using services.
 * @throws DatabaseException IOException
  */
  @Override
  public void run(String... args) throws DatabaseException, IOException {
    File file = new File("../assets/stocks.csv");
    System.out.println("File " + file.getName());
    List<List<String>> records = new App().readCsvFile(file);
    System.out.println("records:  " + file.getName());
    for (List<String> record: records){
      Stock s1 = stockService.create(new Stock(record.get(0), Double.parseDouble(record.get(2)), Double.parseDouble(record.get(1)), 0.02));
    }
    createCallPutOptions(stockService, optionService);
    // precalculate all the prices for that day here or: fix the start price and calculate all other future prices with diffenet time on scheduled message
  }

  double timeDiffSec = 2;
  double mu = 0.1;
  double sigma = 0.1;
  double randInt = 0.0;
  Random one = new Random();

        /**
     * This method returns the next brownian motion price based on current price for a time delta of 2 seconds.
     *
     * @param initialPrice the current price of a stock
     * @return the new stock price based on brownian motion
     */
  public double getLatestBrownianPrice(double initialPrice){
      randInt = one.nextGaussian();
      double newPrice = initialPrice * (1 + (mu * (timeDiffSec/7257600) + sigma * randInt * Math.sqrt(timeDiffSec/7257600)));
      initialPrice = newPrice;
      return initialPrice;
  }

        /**
     * This method is scheduled to run every 2 seconds and fetches the latest brownian prices for each stock and updates it in database.
     */
  @Scheduled(fixedRate = 2000L)
  public void sendMessage() throws DatabaseException{
    LocalTime myObj = LocalTime.now();
    System.out.println("## " + updateNum + " Market Data Update    [Created At:" + myObj + "]");
    updateNum++;
    List<Stock> stocks = stockService.getAccounts();
    List<Double> newPrices = stocks.stream().map(x -> getLatestBrownianPrice(x.getPrice())).collect(Collectors.toList());
    List<Stock> newUpdatedStocks = new ArrayList<>();
    for (int i = 0; i < stocks.size(); i++) {
      Stock sUpdated = stocks.get(i);
      sUpdated.setPrice(newPrices.get(i));
      newUpdatedStocks.add(sUpdated);
    }
    stockService.updateMultiple(newUpdatedStocks);
    // for each of the stocks in stocks.csv publish a new price (and add randomised controls on whether there are updates for stock:)
  }

}